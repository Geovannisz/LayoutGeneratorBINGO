/**
 * beam_pattern.js
 *
 * Module for fetching antenna element field data, calculating the Array Factor (AF)
 * based on the current layout generated by generator.js, applying the AF to the
 * element pattern, and plotting the resulting beam pattern using Plotly.js.
 */

// === Constants ===
// Frequency for calculation (Hz). Let's use 1 GHz as a default, similar to the base rE_table.
// You might want to make this user-selectable or link it to specific data files later.
const FREQUENCY = 1e9; // 1 GHz
const C_LIGHT = 299792458; // Speed of light (m/s)
const LAMBDA = C_LIGHT / FREQUENCY; // Wavelength (m)
const K = (2 * Math.PI) / LAMBDA; // Wavenumber (rad/m)

// Path to the E-field data CSV file
const E_FIELD_CSV_PATH = 'data/rE_table_vivaldi.csv';

// Cache for fetched and parsed E-field data to avoid repeated downloads/parsing
let parsedEFieldData = null;
let isFetchingData = false;
let fetchPromise = null;


// === Data Fetching and Parsing ===

/**
 * Fetches and parses the E-field data CSV file.
 * Converts units (mV to V) and creates complex number representations.
 * Caches the result in the `parsedEFieldData` variable.
 * Handles concurrent fetch requests.
 * @returns {Promise<Array<Object>>} A promise that resolves with the parsed data array.
 */
async function fetchAndParseEFieldData() {
    // If data is already parsed, return it immediately
    if (parsedEFieldData) {
        console.log("Using cached E-field data.");
        return parsedEFieldData;
    }

    // If a fetch is already in progress, return the existing promise
    if (isFetchingData && fetchPromise) {
        console.log("Waiting for ongoing E-field data fetch...");
        return fetchPromise;
    }

    // Start a new fetch operation
    isFetchingData = true;
    console.log(`Fetching E-field data from: ${E_FIELD_CSV_PATH}`);

    fetchPromise = new Promise(async (resolve, reject) => {
        try {
            const response = await fetch(E_FIELD_CSV_PATH);
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status} while fetching ${E_FIELD_CSV_PATH}`);
            }
            const csvText = await response.text();
            console.log("CSV data fetched successfully. Parsing...");

            // Parse the CSV text
            const lines = csvText.trim().split('\n');
            if (lines.length < 2) {
                throw new Error("CSV file is empty or has no data rows.");
            }

            // Process header - **FIX:** Remove quotes, then trim, then lowercase
            const headersRaw = lines[0].split(',');
            const headers = headersRaw.map(h => h.replace(/"/g, '').trim().toLowerCase()); // Remove quotes ""
            console.log("Processed Headers:", headers); // Log processed headers for debugging

            // Find indices of required columns using the *processed* headers
            const thetaIndex = headers.indexOf('theta [deg]');
            const phiIndex = headers.indexOf('phi [deg]');
            // Use the correctly processed lowercase headers without quotes for matching
            const reThetaIndex = headers.indexOf('re(retheta) [mv]');
            const imThetaIndex = headers.indexOf('im(retheta) [mv]');
            const rePhiIndex = headers.indexOf('re(rephi) [mv]');
            const imPhiIndex = headers.indexOf('im(rephi) [mv]');

            // Basic validation of header indices
            if ([thetaIndex, phiIndex, reThetaIndex, imThetaIndex, rePhiIndex, imPhiIndex].some(index => index === -1)) {
                console.error("Required columns not found in CSV header. Check processed headers above. Expected: 'theta [deg]', 'phi [deg]', 're(retheta) [mv]', 'im(retheta) [mv]', 're(rephi) [mv]', 'im(rephi) [mv]'");
                throw new Error("CSV header missing required columns (Theta, Phi, re/im ETheta/EPhi). Check console for details.");
            }

            const data = [];
            // Process data lines
            for (let i = 1; i < lines.length; i++) {
                // **FIX:** Also remove quotes from data values if they exist (though usually not present in data rows)
                const valuesRaw = lines[i].split(',');
                const values = valuesRaw.map(v => v.replace(/"/g, '').trim());

                if (values.length === headers.length) {
                    try {
                        const theta = parseFloat(values[thetaIndex]);
                        const phi = parseFloat(values[phiIndex]);
                        // Convert mV to V and create complex numbers
                        const reThetaV = parseFloat(values[reThetaIndex]) * 1e-3;
                        const imThetaV = parseFloat(values[imThetaIndex]) * 1e-3;
                        const rePhiV = parseFloat(values[rePhiIndex]) * 1e-3;
                        const imPhiV = parseFloat(values[imPhiIndex]) * 1e-3;

                        // Basic validation of parsed numbers
                        if ([theta, phi, reThetaV, imThetaV, rePhiV, imPhiV].some(isNaN)) {
                           // console.warn(`Skipping row ${i + 1} due to non-numeric values.`);
                            continue; // Skip row if any value is not a number
                        }

                        const rETheta = { re: reThetaV, im: imThetaV };
                        const rEPhi = { re: rePhiV, im: imPhiV };

                        // Calculate rETotal magnitude for the single element pattern
                        const rETotalMag = Math.sqrt(rETheta.re**2 + rETheta.im**2 + rEPhi.re**2 + rEPhi.im**2);

                        data.push({
                            theta: theta,
                            phi: phi,
                            rETheta: rETheta, // Store as complex object
                            rEPhi: rEPhi,     // Store as complex object
                            rETotal: rETotalMag // Store magnitude
                        });
                    } catch (parseError) {
                        console.warn(`Error parsing row ${i + 1}: ${lines[i]}. Error: ${parseError.message}`);
                        // Continue parsing other lines
                    }
                } else if (lines[i]) { // Avoid warning for empty lines
                     console.warn(`Skipping row ${i + 1} due to incorrect number of columns (${values.length} found, ${headers.length} expected).`);
                }
            }

            console.log(`Parsing complete. ${data.length} data points loaded.`);
            parsedEFieldData = data; // Cache the parsed data
            isFetchingData = false;
            resolve(parsedEFieldData);

        } catch (error) {
            console.error("Error fetching or parsing E-field data:", error);
            isFetchingData = false;
            fetchPromise = null; // Reset promise on error
            // Propagate the error
            reject(error);
        }
    });

    return fetchPromise;
}


// === Array Factor (AF) Calculation ===

/**
 * Calculates the complex Array Factor (AF) for a given set of antenna positions.
 *
 * @param {Array<number>} theta Array of theta angles in degrees.
 * @param {Array<number>} phi Array of phi angles in degrees. Must be same length as theta.
 * @param {Array<Array<number>>} antennaCoords Array of [x, y] coordinates for each antenna element relative to the array center.
 * @param {number} k Wavenumber (2 * pi / lambda).
 * @param {number} theta_0 Scan angle theta in degrees (default: 0).
 * @param {number} phi_0 Scan angle phi in degrees (default: 0).
 * @returns {Array<Object>} Array of complex AF values {re, im} corresponding to each theta/phi pair.
 */
function computeAF(theta, phi, antennaCoords, k, theta_0 = 0, phi_0 = 0) {
    console.log(`Computing AF for ${antennaCoords.length} antennas...`);
    if (theta.length !== phi.length) {
        throw new Error("Theta and Phi arrays must have the same length.");
    }
    if (antennaCoords.length === 0) {
        console.warn("Antenna coordinates array is empty. Returning AF = 1.");
        // Return an array of {re: 1, im: 0} with the same length as theta/phi
        return Array(theta.length).fill({ re: 1, im: 0 });
    }

    const numAntennas = antennaCoords.length;
    const numPoints = theta.length;
    const af_complex = Array(numPoints).fill(null).map(() => ({ re: 0, im: 0 })); // Initialize complex AF array

    // Convert scan angles to radians
    const theta_0_rad = theta_0 * (Math.PI / 180);
    const phi_0_rad = phi_0 * (Math.PI / 180);

    // Calculate the scan vector components (fixed for all points)
    const scanVecX = Math.sin(theta_0_rad) * Math.cos(phi_0_rad);
    const scanVecY = Math.sin(theta_0_rad) * Math.sin(phi_0_rad);
    const scanVecZ = Math.cos(theta_0_rad); // Assuming z=0 for antennas simplifies this later

    // Pre-calculate antenna positions (ensure they are numbers)
    const antX = antennaCoords.map(coord => Number(coord[0]));
    const antY = antennaCoords.map(coord => Number(coord[1]));
    // Assuming z=0 for all antennas based on how generator.js provides them

    // Iterate through each observation angle (theta, phi pair)
    for (let i = 0; i < numPoints; i++) {
        const theta_rad = theta[i] * (Math.PI / 180);
        const phi_rad = phi[i] * (Math.PI / 180);

        // Calculate observation vector components for this point
        const obsVecX = Math.sin(theta_rad) * Math.cos(phi_rad);
        const obsVecY = Math.sin(theta_rad) * Math.sin(phi_rad);
        const obsVecZ = Math.cos(theta_rad);

        // Calculate difference vector components
        const diffX = obsVecX - scanVecX;
        const diffY = obsVecY - scanVecY;
        const diffZ = obsVecZ - scanVecZ; // Will be multiplied by antenna z=0

        let sumRe = 0;
        let sumIm = 0;

        // Sum contributions from each antenna element
        for (let j = 0; j < numAntennas; j++) {
            // Calculate phase: k * (difference_vector . antenna_position_vector)
            // Since antenna z=0, dot product simplifies: k * (diffX * antX[j] + diffY * antY[j] + diffZ * 0)
            const phase = k * (diffX * antX[j] + diffY * antY[j]);

            // Calculate complex exponential: exp(1j * phase) = cos(phase) + j*sin(phase)
            sumRe += Math.cos(phase);
            sumIm += Math.sin(phase);
        }

        // Store the complex sum for this angle pair
        af_complex[i] = { re: sumRe, im: sumIm };
    }

    console.log("AF computation finished.");
    // The AF here is the sum, not normalized by default like in some definitions.
    // We will multiply the single element pattern by this complex AF.
    return af_complex;
}


// === Applying AF to Field Data ===

/**
 * Multiplies the single element's complex E-field pattern by the complex Array Factor.
 * This represents the total E-field of the array (element pattern * array factor).
 *
 * @param {Array<Object>} elementFieldData Parsed E-field data for the single element (from fetchAndParseEFieldData).
 * @param {Array<Object>} afComplex Array of complex AF values corresponding to the field data points.
 * @returns {Array<Object>} Array containing the resulting complex E-field {theta, phi, rEThetaTotal, rEPhiTotal, rETotalMagnitude}.
 */
function applyAF(elementFieldData, afComplex) {
    console.log("Applying AF to element field data...");
    if (elementFieldData.length !== afComplex.length) {
        throw new Error("Field data and AF arrays must have the same length.");
    }

    const resultingField = [];

    for (let i = 0; i < elementFieldData.length; i++) {
        const element = elementFieldData[i];
        const af = afComplex[i];

        // Complex multiplication: (a+bi) * (c+di) = (ac-bd) + (ad+bc)i
        // rEThetaTotal = element.rETheta * af
        const rEThetaTotal_re = element.rETheta.re * af.re - element.rETheta.im * af.im;
        const rEThetaTotal_im = element.rETheta.re * af.im + element.rETheta.im * af.re;

        // rEPhiTotal = element.rEPhi * af
        const rEPhiTotal_re = element.rEPhi.re * af.re - element.rEPhi.im * af.im;
        const rEPhiTotal_im = element.rEPhi.re * af.im + element.rEPhi.im * af.re;

        const rEThetaTotal = { re: rEThetaTotal_re, im: rEThetaTotal_im };
        const rEPhiTotal = { re: rEPhiTotal_re, im: rEPhiTotal_im };

        // Calculate the magnitude of the total resulting field
        const rETotalMagnitude = Math.sqrt(
            rEThetaTotal_re**2 + rEThetaTotal_im**2 +
            rEPhiTotal_re**2 + rEPhiTotal_im**2
        );

        resultingField.push({
            theta: element.theta,
            phi: element.phi,
            rEThetaTotal: rEThetaTotal,
            rEPhiTotal: rEPhiTotal,
            rETotalMagnitude: rETotalMagnitude
        });
    }

    console.log("AF application finished.");
    return resultingField;
}


// === Plotting ===

/**
 * Plots the beam pattern using Plotly.js.
 *
 * @param {string} targetDivId ID of the div element where the plot should be rendered.
 * @param {Array<number>} theta Array of theta angles (degrees).
 * @param {Array<number>} fieldMagnitude Array of the magnitude of the total field (linear scale).
 * @param {number} phiValue The Phi angle (degrees) for which the pattern is plotted (used for title).
 */
function plotBeamPattern(targetDivId, theta, fieldMagnitude, phiValue) {
    console.log(`Plotting beam pattern for Phi = ${phiValue}° in div #${targetDivId}`);
    const plotDiv = document.getElementById(targetDivId);
    if (!plotDiv) {
        console.error(`Target div "${targetDivId}" not found for plotting.`);
        return;
    }

     // Clear previous plot if any
    Plotly.purge(plotDiv);

    // Find peak magnitude and normalize
    const peakMagnitude = Math.max(...fieldMagnitude);
    const fieldMagnitudeNormalizedDb = fieldMagnitude.map(mag => {
        // Prevent log10(0) or negative values
        if (mag <= 0 || peakMagnitude <= 0) return -100; // Assign a low dB value
        const normalizedMag = mag / peakMagnitude;
        // Add small epsilon to avoid log10(0) if normalizedMag becomes exactly 0
        const magForDb = Math.max(normalizedMag, 1e-10);
        return 20 * Math.log10(magForDb);
    });


    const trace = {
        x: theta,
        y: fieldMagnitudeNormalizedDb, // Plot magnitude in dB relative to peak
        mode: 'lines',
        type: 'scatter',
        name: `Phi = ${phiValue}°`,
        line: {
            color: '#8be9fd' // Use a Dracula theme color (cyan)
        }
    };

    // Define layout using Dracula theme colors (adjust as needed)
    const layout = {
        title: `Padrão de Feixe Normalizado (Phi = ${phiValue}°)`,
        xaxis: {
            title: 'Theta (graus)',
            gridcolor: '#44475a', // Dracula grid color
            zerolinecolor: '#6272a4', // Dracula slightly lighter grid
            linecolor: '#6272a4',
            tickcolor: '#f8f8f2',
            titlefont: { color: '#f8f8f2' },
            tickfont: { color: '#f8f8f2' },
            range: [-90, 90] // Set fixed theta range -90 to 90
        },
        yaxis: {
            title: 'Magnitude Normalizada (dB)',
            gridcolor: '#44475a',
            zerolinecolor: '#6272a4',
            linecolor: '#6272a4',
            tickcolor: '#f8f8f2',
            titlefont: { color: '#f8f8f2' },
            tickfont: { color: '#f8f8f2' },
             range: [-60, 0] // Typical dB range for beam patterns
        },
        plot_bgcolor: '#282a36', // Dracula background
        paper_bgcolor: '#282a36', // Dracula background
        font: {
            color: '#f8f8f2' // Dracula text color
        },
        showlegend: false // Hide legend if only one trace
    };

    Plotly.newPlot(targetDivId, [trace], layout)
        .then(() => console.log(`Plotly chart rendered successfully for Phi = ${phiValue}°.`))
        .catch(err => console.error("Error rendering Plotly chart:", err));
}


// === Initialization and Event Handling ===

/**
 * Initializes the controls for the beam pattern section.
 */
function initBeamPatternControls() {
    const phiSelect = document.getElementById('beam-phi-select');
    const generateButton = document.getElementById('generate-beam-btn');
    const plotDivId = 'beam-pattern-plot'; // ID of the div for the plot
    const statusDiv = document.getElementById('beam-status');

    if (!phiSelect || !generateButton || !statusDiv) {
        console.error("Beam pattern controls (select, button, status div, or plot div) not found in the DOM.");
        return;
    }

    // Add common Phi angles as options (ensure data file contains these)
    // Check your CSV for available Phi values if needed.
    const commonPhiAngles = [0, 45, 90, 135, 180, 225, 270, 315]; // Common angles often present
     // TODO: Dynamically populate based on unique Phi values in fetched data?
     commonPhiAngles.forEach(angle => {
         const option = document.createElement('option');
         option.value = angle;
         option.textContent = `${angle}°`;
         phiSelect.appendChild(option);
     });
     // Set default selection
     phiSelect.value = '90';


    generateButton.addEventListener('click', async () => {
        console.log("Generate Beam Pattern button clicked.");
        statusDiv.textContent = 'Gerando padrão de feixe...';
        generateButton.disabled = true;

        try {
            // 1. Get antenna coordinates from the generator module
            if (!window.antennaGenerator || typeof window.antennaGenerator.getAllAntennas !== 'function') {
                throw new Error("Antenna generator module (window.antennaGenerator) not found or is missing getAllAntennas method.");
            }
            const antennaCoords = window.antennaGenerator.getAllAntennas();
            if (!antennaCoords || antennaCoords.length === 0) {
                 throw new Error("Nenhum layout de antena gerado ainda. Gere um layout primeiro.");
            }
             console.log(`Retrieved ${antennaCoords.length} antenna coordinates for AF calculation.`);


            // 2. Fetch and parse E-field data (uses cache if available)
            statusDiv.textContent = 'Carregando dados do elemento...';
            const elementData = await fetchAndParseEFieldData();

            // 3. Get selected Phi value
            const selectedPhi = parseFloat(phiSelect.value);
            statusDiv.textContent = `Filtrando dados para Phi = ${selectedPhi}°...`;

            // 4. Filter element data for the selected Phi
            const filteredData = elementData.filter(point => Math.abs(point.phi - selectedPhi) < 1e-6); // Use tolerance for float comparison
            if (filteredData.length === 0) {
                throw new Error(`Não foram encontrados dados para Phi = ${selectedPhi}°. Verifique o arquivo CSV ou selecione outro ângulo.`);
            }
            const thetaValues = filteredData.map(point => point.theta);
             // Create a corresponding phiValues array of the same length
             const phiValues = Array(thetaValues.length).fill(selectedPhi);


            // 5. Calculate Array Factor
            statusDiv.textContent = 'Calculando Fator de Arranjo (AF)...';
            // Ensure thetaValues and phiValues are passed correctly
             const afComplex = computeAF(thetaValues, phiValues, antennaCoords, K);


            // 6. Apply AF to the element pattern
            statusDiv.textContent = 'Aplicando AF ao padrão do elemento...';
            const resultingField = applyAF(filteredData, afComplex);

            // 7. Extract magnitude for plotting
            const resultingMagnitude = resultingField.map(point => point.rETotalMagnitude);

            // 8. Plot the result
            statusDiv.textContent = 'Renderizando gráfico...';
            plotBeamPattern(plotDivId, thetaValues, resultingMagnitude, selectedPhi);

            statusDiv.textContent = `Padrão de feixe para Phi = ${selectedPhi}° gerado com sucesso.`;

        } catch (error) {
            console.error("Error generating beam pattern:", error);
            statusDiv.textContent = `Erro: ${error.message}`;
             // Clear the plot area on error
             const plotDiv = document.getElementById(plotDivId);
             if (plotDiv) Plotly.purge(plotDiv);
        } finally {
            generateButton.disabled = false; // Re-enable button
        }
    });

    console.log("Beam pattern controls initialized.");
}

// Initialize controls when the DOM is ready
document.addEventListener('DOMContentLoaded', initBeamPatternControls);